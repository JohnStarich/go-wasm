<html>

<head>
	<meta charset="utf-8" />
	<script src="wasm_exec.js"></script>
	<script src="reload.js"></script>
	<script>
		if (!WebAssembly.instantiateStreaming) { // polyfill
			WebAssembly.instantiateStreaming = async (resp, importObject) => {
				const source = await (await resp).arrayBuffer();
				return await WebAssembly.instantiate(source, importObject);
			};
		}

		const load = (name, go) =>
			WebAssembly.instantiateStreaming(fetch(`${name}.wasm`), go.importObject)
				.catch(e => {
					console.error(`Failed to load ${name}`, e)
				})

		async function run(name, ...args) {
			const downloadPath = `/bin/${name}`
			if (! await exists(downloadPath)) {
				const wasmBinary = await fetch(`${name}.wasm`)
				const buf = await wasmBinary.arrayBuffer()
				await writeBytes(downloadPath, new Uint8Array(buf))
				fs.chmodSync(downloadPath, 0o700)
			}
			return await spawn(downloadPath, ...args)
		}

		function runGo(...args) {
			const go = new Go();
			return load('go', go).then(m => {
				go.env = {
					'GOROOT': '/go',
					'HOME': process.cwd(),
				}
				go.argv = ['go', ...args]
				go.run(m.instance)
			})
		}

		function ls(path) {
			if (!path) {
				path = ""
			}
			console.log(fs.readdirSync(path))
		}

		function rm(path) {
			if (!path) {
				path = ""
			}
			fs.unlinkSync(path)
		}

		function cat(path) {
			const fd = fs.openSync(path)
			if (fd) {
				const buf = new Uint8Array(4096)
				const n = fs.readSync(fd, buf, 0, buf.length, 0)
				console.log(new TextDecoder("utf-8").decode(buf).substr(0, n))
				fs.closeSync(fd)
			}
		}

		function exists(path) {
			return new Promise(resolve => {
				fs.stat(path, err => resolve(!err))
			})
		}

		function fstat(fd) {
			return new Promise((resolve, reject) => {
				fs.fstat(fd, (err, stats) => {
					if (err) {
						reject(err)
						return
					}
					resolve(stats)
				})
			})
		}

		function readOnceFD(fd) {
			return new Promise((resolve, reject) => {
				const buf = new Uint8Array(4096)
				fs.read(fd, buf, 0, buf.length, null, (err, n, buf) => {
					if (err) {
						reject(err)
						return
					}
					const data = new TextDecoder("utf-8").decode(buf).substr(0, n)
					resolve([n, data])
				})
			})
		}

		function readFD(fd) {
			return new Promise((resolve, reject) => {
				let s = ""
				let intervalID = setInterval(async () => {
					let [n, data] = await readOnceFD(fd)
					if (n > 0) {
						s += data
					}
					const stat = await fstat(fd)
					if (stat.size === 0) {
						clearInterval(intervalID)
						resolve(s)
					}
				}, 1)
			})
		}

		function writeFD(fd, contents) {
			const buf = new TextEncoder("utf-8").encode(contents)
			return new Promise((resolve, reject) => {
				fs.write(fd, buf, 0, buf.length, null, (err, n, buf) => {
					if (err) {
						reject(err)
						return
					}
					fs.close(fd, err => {
						if (err) {
							reject(err)
							return
						}
						resolve([n, buf])
					})
				})
			})
		}

		function writeBytes(path, contents) {
			const fd = fs.openSync(path, fs.constants.O_WRONLY|fs.constants.O_CREAT|fs.constants.O_TRUNC)
			if (fd) {
				fs.writeSync(fd, contents, 0, contents.length, null)
				fs.closeSync(fd)
			}
		}

		function write(path, contents) {
			const fd = fs.openSync(path, fs.constants.O_WRONLY|fs.constants.O_CREAT|fs.constants.O_TRUNC)
			if (fd) {
				const buf = new TextEncoder("utf-8").encode(contents)
				fs.writeSync(fd, buf, 0, buf.length, null)
				fs.closeSync(fd)
			}
		}

		function pipe() {
			return new Promise((resolve, reject) => {
				fs.pipe((err, fds) => {
					if (err) {
						reject(err)
						return
					}
					resolve({r: fds[0], w: fds[1]})
					return
				})
			})
		}

		function spawn(...args) {
			return new Promise((resolve, reject) => {
				const subprocess = child_process.spawn(args[0], args.slice(1))
				if (! subprocess) {
					reject(new Error(`Failed to spawn command: ${args}`))
					return
				}
				child_process.wait(subprocess.pid, (err, pid) => {
					if (err) {
						reject(err)
						return
					}
					resolve(pid)
				})
			})
		}

		const go = new Go();
		load('polyfill', go)
			.then(async cmd => {
				go.env = {
					'PATH': '/bin:/go/bin/js_wasm:/go/pkg/tool/js_wasm',
					'GOROOT': '/go',
					'HOME': '/home/me',
				}
				go.run(cmd.instance)
				console.log(`go-wasm status: ${goWasm.ready ? 'ready' : 'not ready'}`)

				fs.mkdirSync("/bin", 0o755)
				fs.mkdirSync("/go", 0o755)
				run('main')
					.then(() => spawn("go", "version"))
					//.then(() => spawn("go", "build", "-n", "-v", "-o", "./prog", "main.go"))
					.then(() => spawn("compile", "main.go"))
					.then(() => spawn("link", "-o", "main", "main.o"))
					.then(() => spawn("./main"))
			})
	</script>
</head>

<body></body>

</html>
