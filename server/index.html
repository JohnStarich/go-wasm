<html>

<head>
	<meta charset="utf-8" />
	<script src="wasm_exec.js"></script>
	<script src="reload.js"></script>
	<script>
		if (!WebAssembly.instantiateStreaming) { // polyfill
			WebAssembly.instantiateStreaming = async (resp, importObject) => {
				const source = await (await resp).arrayBuffer();
				return await WebAssembly.instantiate(source, importObject);
			};
		}

		const load = (name, go) =>
			WebAssembly.instantiateStreaming(fetch(`${name}.wasm`), go.importObject)
				.catch(e => {
					console.error(`Failed to load ${name}`, e)
				})

		function run(name, ...args) {
			const go = new Go();
			go.env = {
				'PATH': '/bin',
			}
			go.argv = [name, ...args]
			return load(name, go).then(m => go.run(m.instance))
		}

		function runGo(...args) {
			const go = new Go();
			return load('go', go).then(m => {
				go.env = {
					'GOROOT': '/go',
					'HOME': process.cwd(),
				}
				go.argv = ['go', ...args]
				go.run(m.instance)
			})
		}

		function ls(path) {
			console.log(fs.readdirSync(path))
		}

		function cat(path) {
			const fd = fs.openSync(path)
			if (fd) {
				const buf = new Uint8Array(4096)
				const n = fs.readSync(fd, buf, 0, buf.length, 0)
				console.log(new TextDecoder("utf-8").decode(buf).substr(0, n))
				fs.closeSync(fd)
			}
		}

		function fstat(fd) {
			return new Promise((resolve, reject) => {
				fs.fstat(fd, (err, stats) => {
					if (err) {
						reject(err)
						return
					}
					resolve(stats)
				})
			})
		}

		function readOnceFD(fd) {
			return new Promise((resolve, reject) => {
				const buf = new Uint8Array(4096)
				fs.read(fd, buf, 0, buf.length, null, (err, n, buf) => {
					if (err) {
						reject(err)
						return
					}
					const data = new TextDecoder("utf-8").decode(buf).substr(0, n)
					resolve([n, data])
				})
			})
		}

		function readFD(fd) {
			return new Promise((resolve, reject) => {
				let s = ""
				let intervalID = setInterval(async () => {
					let [n, data] = await readOnceFD(fd)
					if (n > 0) {
						s += data
					}
					const stat = await fstat(fd)
					if (stat.size === 0) {
						clearInterval(intervalID)
						resolve(s)
					}
				}, 1)
			})
		}

		function writeFD(fd, contents) {
			const buf = new TextEncoder("utf-8").encode(contents)
			return new Promise((resolve, reject) => {
				fs.write(fd, buf, 0, buf.length, null, (err, n, buf) => {
					if (err) {
						reject(err)
						return
					}
					fs.close(fd, err => {
						if (err) {
							reject(err)
							return
						}
						resolve([n, buf])
					})
				})
			})
		}

		function write(path, contents) {
			const fd = fs.openSync(path, fs.constants.O_WRONLY|fs.constants.O_CREAT|fs.constants.O_TRUNC)
			if (fd) {
				const buf = new TextEncoder("utf-8").encode(contents)
				fs.writeSync(fd, buf, 0, buf.length, null)
				fs.closeSync(fd)
			}
		}

		function pipe() {
			return new Promise((resolve, reject) => {
				fs.pipe((err, fds) => {
					if (err) {
						reject(err)
						return
					}
					resolve({r: fds[0], w: fds[1]})
					return
				})
			})
		}

		function spawn(...args) {
			return new Promise((resolve, reject) => {
				const subprocess = child_process.spawn(args[0], args.slice(1))
				child_process.wait(subprocess.pid, (err, pid) => {
					if (err) {
						reject(err)
						return
					}
					resolve(pid)
				})
			})
		}

		const go = new Go();
		load('polyfill', go)
			.then(async cmd => {
				go.env = {
					'PATH': '/bin:/go/bin/js_wasm',
					'GOROOT': '/go',
					'HOME': '/home/me',
				}
				go.run(cmd.instance)
				console.log(`go-wasm status: ${goWasm.ready ? 'ready' : 'not ready'}`)

				fs.mkdirSync("/go", 0o755)
				run('main')
					.then(() => spawn("go", "version"))
					.then(() => spawn("go", "build", "-n", "-v", "-o", "./prog", "main.go"))
			})
	</script>
</head>

<body></body>

</html>
